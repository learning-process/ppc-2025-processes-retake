# Поразрядная сортировка целых чисел с чётно-нечётным слиянием Бэтчера (SEQ | MPI)

- Студент: Черемхин Андрей Александрович, группа 3823Б1ПР3
- Технология: SEQ | MPI
- Вариант: 19

## Введение

Цель задачи — реализовать сортировку целых чисел (int) поразрядным алгоритмом (radix sort) и параллельную MPI-версию,
в которой локально отсортированные блоки объединяются с помощью чётно-нечётного слияния Бэтчера (Batcher odd-even merge)
по процессам.

## Постановка задачи

На вход подаётся вектор целых чисел. Требуется вернуть этот вектор, отсортированный по неубыванию.

Тип входных данных:

```cpp
using InType = std::vector<int>;
```

Тип выходных данных:

```cpp
using OutType = std::vector<int>;
```

## Базовый алгоритм (Sequential)

Используется LSD radix sort по байтам (4 прохода для 32-битного int):

- на каждом проходе выполняется стабильная сортировка подсчётом по текущему байту
- для корректной обработки отрицательных чисел используется преобразование ключа: `key = (uint32_t)value ^ 0x80000000`
  (это переводит порядок signed в порядок unsigned)

Сложность:

- O(4 * n) по времени
- O(n) по памяти

## Схема распараллеливания (MPI): Бэтчер (odd-even merge) по процессам

1. Rank 0 дополняет вход до кратности числу процессов (padding значением `INT_MAX`) и распределяет блоки одинакового размера по процессам (`MPI_Scatter`).
2. Каждый процесс сортирует свой блок локально тем же radix sort.
3. Далее выполняется сеть компараторов Бэтчера по процессам (для количества процессов = степень двойки):
   - на каждом компараторе два процесса обмениваются своими отсортированными блоками (`MPI_Sendrecv`)
   - выполняют слияние двух отсортированных массивов (merge)
   - процесс с меньшим rank оставляет “меньшую половину” своего размера, процесс с большим rank — “большую половину”
4. Rank 0 собирает итог (`MPI_Gather`), отбрасывает padding и рассылает результат всем (`MPI_Bcast`), чтобы `GetOutput()` был валиден на каждом процессе.

Примечание: если число процессов не является степенью двойки, используется безопасный fallback на чётно-нечётные соседние обмены
(odd-even transposition), чтобы задача корректно работала в любом запуске.

## Детали реализации

Структура задачи:

```
tasks/cheremkhin_a_radix_sort_batcher/
├── common/include/common.hpp
├── seq/include/ops_seq.hpp
├── seq/src/ops_seq.cpp
├── mpi/include/ops_mpi.hpp
├── mpi/src/ops_mpi.cpp
├── tests/functional/main.cpp
├── tests/performance/main.cpp
├── settings.json
├── info.json
└── report.md
```

Классы:

- `CheremkhinARadixSortBatcherSEQ`
- `CheremkhinARadixSortBatcherMPI`

## Проверка корректности

Functional-тесты (`tests/functional/main.cpp`) проверяют:

- сортировку уже отсортированного массива
- сортировку в обратном порядке
- наличие отрицательных чисел и повторов
- тривиальные случаи (1 элемент)

Ожидаемый результат вычисляется как `std::sort` над копией входа.

## Производительность

Ниже приведены результаты одного прогона. Базовая точка для расчёта ускорения — SEQ (1 запуск).

pipeline:

| Mode | Count | Time, s | Speedup | Efficiency |
|------|------:|--------:|--------:|-----------:|
| seq  | 1 | 0.1738711160 | 1.00 | N/A |
| mpi  | 1 | 0.2733182060 | 0.64 | 63.6% |
| mpi  | 2 | 0.2901480690 | 0.60 | 30.0% |
| mpi  | 3 | 0.3290196940 | 0.53 | 17.6% |
| mpi  | 4 | 0.3667764640 | 0.47 | 11.9% |
| mpi  | 5 | 0.3904221110 | 0.45 | 8.9% |
| mpi  | 12 | 0.7389914400 | 0.24 | 2.0% |

task_run:

| Mode | Count | Time, s | Speedup | Efficiency |
|------|------:|--------:|--------:|-----------:|
| seq  | 1 | 0.1557295400 | 1.00 | N/A |
| mpi  | 1 | 0.2596250240 | 0.60 | 60.0% |
| mpi  | 2 | 0.2384910110 | 0.65 | 32.6% |
| mpi  | 3 | 0.3234444180 | 0.48 | 16.0% |
| mpi  | 4 | 0.3261312520 | 0.48 | 11.9% |
| mpi  | 5 | 0.2590720800 | 0.60 | 12.0% |
| mpi  | 12 | 0.6011320870 | 0.26 | 2.2% |


- В данной реализации основное время при увеличении числа процессов уходит в коммуникации и многократные слияния в сети Бэтчера.
- Для числа процессов, не являющегося степенью двойки (например, 3, 5, 12), используется fallback (odd-even transposition), который добавляет дополнительные фазы обмена и ухудшает масштабируемость.


## Источники

1. [Материалы курса: отчёт (требования и структура)](https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html#overview-and-placement)

