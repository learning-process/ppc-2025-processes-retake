#Подсчет числа слов в строке
- Студент: Федосеев Сегрей Николаевич, группа 3823Б1ФИ1

- Технология: SEQ | MPI

- Вариант: 24

## 1. Introduction
Разработка последовательной (SEQ) и распараллеленной (MPI) версий алгоритма подсчёта слов в строке. Основная цель - исследование возможности ускорения обработки текстовой информации за счет распределения вычислений между несколькими процессами. Особое внимание уделено корректной обработке границ слов при разделении строки между процессами.

## 2. Problem Statement
Требуется определить количество слов в произвольной строке. Слово определяется как максимальная непрерывная последовательность непробельных символов, где пробельными считаются символы, для которых стандартная функция std::isspace() возвращает истинное значение (пробел, табуляция, перевод строки и др.).

Входные данные: строка произвольной длины, содержащая символы ASCII и Unicode.
Выходные данные: целое число, представляющее количество слов в строке.

## 3. Baseline Algorithm (Sequential)
Базовый алгоритм проходит по строке однократно, отслеживая состояние "внутри слова". Основная логика основана на обнаружении переходов между пробельными и непробельными символами.
'''
int count_words_seq(const std::string& s) {
    int count = 0;
    bool in_word = false;
    
    for (char ch : s) {
        auto uc = static_cast<unsigned char>(ch);
        bool is_space = std::isspace(uc) != 0;
        
        if (!is_space) {
            if (!in_word) {
                ++count;
                in_word = true;
            }
        } else {
            in_word = false;
        }
    }
    
    return count;
}
'''
Алгоритм имеет линейную сложность O(n), где n — длина строки.

## 4. Parallelization Scheme
Распределение данных: блочное распределение строки по символам.
Если длина строки N, количество процессов P, каждый процесс получает:
'''
chunk_size = N / P
start = rank * chunk_size
end = (rank == P-1) ? N : (rank + 1) * chunk_size
'''
Для корректной обработки границ слов выполняются корректировки границ:
- Если процесс не первый (rank > 0) и начало фрагмента находится внутри слова, граница сдвигается к началу следующего слова
- Если процесс не последний (rank < P-1) и конец фрагмента находится внутри слова, граница сдвигается к концу текущего слова

Коммуникация:
- Каждый процесс подсчитывает слова в своем фрагменте
- Используется MPI_Reduce для суммирования локальных результатов на процессе 0
- Используется MPI_Bcast для рассылки общего результата всем процессам

Роли рангов:
- Rank 0: получение финального результата через Reduce, рассылка результата через Bcast
- Rank 1..P-1: подсчет слов в локальных сегментах, участие в Reduce и Bcast
## 5. Implementation Details
Структура кода:
tasks/fedoseev_count_words_in_string/
├── common
│   └── include
│       └── common.hpp
├── info.json
├── mpi
│   ├── include
│   │   └── ops_mpi.hpp
│   └── src
│       └── ops_mpi.cpp
├── report.md
├── seq
│   ├── include
│   │   └── ops_seq.hpp
│   └── src
│       └── ops_seq.cpp
├── settings.json
└── tests
    ├── functional
    │   └── functional.cpp
    └── performance
        └── performance.cpp
Ключевые особенности реализации MPI:
- Использование MPI_Reduce для сбора результатов на процессе 0
- Использование MPI_Bcast для распространения результата
- Корректная обработка границ слов между процессами
- Каждый процесс работает с полной строкой, но вычисляет только свой фрагмент
- Линейная сложность по размеру локального блока
## 6. Experimental Setup
- **Hardware/OS:** Intel Core i7-12700H, 8 cores / 20 threads, 16GB RAM, Ubuntu 24.04.3 LTS  
- **Toolchain:** gcc 14, OpenMPI 4.1.4  
- **Build type:** Release  
- **Environment:** PPC_NUM_THREADS / PPC_NUM_PROC: 1 / 8  
- **Data:** строки длиной от 0 до 50 000 символов, включая:
  - ASCII
  - Unicode (русский текст)
  - emoji
  - наборы смешанных пробельных символов
## 7. Results and Discussion
### 7.1 Correctness
Полная проверка корректности через функциональные тесты
Сравнение MPI и SEQ для всех вариантов входных данных
Проверка граничных условий: пустая строка, строка из пробелов, строка длины 1
Все тесты в SEQ и MPI пройдены успешно
### 7.2 Performance
Speedup = T_seq / T_parallel
Efficiency = Speedup / P * 100%

Измерения "чистого" времени подсчёта слов — task_run
Mode	Процессы	Время, мс	Ускорение	Эффективность
seq	           1	    0.015	    1.00	        N/A
mpi            2	    0.028    	0.54	        27%
mpi	           4	    0.035	    0.43            11%


Полное время выполнения (инициализация, коммуникации) — pipeline
Mode	Процессы	Время, мс	Ускорение	Эффективность
seq	           1	     0.42	    1.00	        N/A
mpi	           2     	 0.38	    1.11	        56%
mpi	           4	     0.45	    0.93	        23%

Ограничения масштабируемости:
- Коммуникационные затраты становятся доминирующими при увеличении числа процессов
- Задача имеет низкую вычислительную плотность по сравнению с накладными расходами MPI
- Накладные расходы на синхронизацию (MPI_Reduce, MPI_Bcast) ограничивают ускорение

"Бутылочные горлышки":
- Коллективные операции MPI (Reduce, Bcast)
- Инициализация процессов MPI, которая для малых задач занимает значительное время
- Необходимость корректировки границ фрагментов для избежания разрезания слов

Порог эффективности:
- MPI оправдан для строк длиной от ~50 000 символов
- Для малых и средних строк SEQ быстрее
- Оптимальное число процессов для данной задачи: 2-4

## 8. Conclusions
- Реализованы корректные SEQ и MPI версии алгоритма подсчета слов в строке
- MPI-реализация использует блочное распределение данных с корректировкой границ для сохранения целостности слов
- Использованы коллективные операции MPI (Reduce, Bcast) для сбора и распространения результатов
- Основное ограничение — низкая вычислительная плотность задачи и высокая цена MPI-коммуникаций
- Последовательная версия остается предпочтительной для большинства практических случаев, но MPI демонстрирует потенциал для очень больших строк
- Дальнейшая оптимизация могла бы включать асинхронные коммуникации и более эффективные схемы распределения данныx
## 9. References
1. OpenMPI документация: <https://www.open-mpi.org/>  
2. MPI стандарт: <https://www.mpi-forum.org/>  
3. Материалы курса: <https://learning-process.github.io/parallel_programming_course/ru/common_information/report.html>  
4. Мастер-репозиторий PPC 2025: <https://github.com/learning-process/ppc-2025-processes-informatics>