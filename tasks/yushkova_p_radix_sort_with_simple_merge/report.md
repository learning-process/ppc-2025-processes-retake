# Поразрядная сортировка для вещественных чисел (тип double) с простым слиянием.

- Student: Юшкова Полина Александровна, group 3823Б1ПР2
- Technology: SEQ + MPI
- Variant: 20

## 1. Введение

Сортировка вещественных чисел типа `double` является важной задачей в вычислительных приложениях, где требуется быстро и корректно упорядочивать большие массивы данных. Для таких задач поразрядная сортировка (LSD radix sort) интересна тем, что позволяет получить линейную по числу элементов обработку каждого прохода и предсказуемое время работы.

Особенность работы с `double` состоит в том, что прямое сравнение битовых представлений не даёт корректного числового порядка для отрицательных и положительных значений одновременно. Поэтому в реализации используется преобразование `double` в специальный `uint64`-ключ, сохраняющий правильный порядок при поразрядной сортировке.

В работе реализованы:
- последовательная версия алгоритма;
- параллельная версия на MPI с локальной поразрядной сортировкой и простым двухпутевым слиянием отсортированных частей.

Ожидаемый результат:
- корректная сортировка массива `double` (включая отрицательные значения, нули и повторяющиеся элементы);
- совпадение результата SEQ и MPI-версий;
- получение ускорения MPI-версии на многопроцессорном запуске при росте размера входных данных.

## 2. Постановка задачи

Требуется реализовать алгоритм поразрядной сортировки для массива вещественных чисел типа `double` с использованием простого слияния отсортированных частей.

### 2.1. Входные данные

- `InType = std::vector<double>` — одномерный массив вещественных чисел произвольной длины `N >= 0`.

### 2.2. Выходные данные

- `OutType = std::tuple<std::vector<double>, int>`, где:
- первый элемент — отсортированный по неубыванию массив `double`;
- второй элемент — служебный код/ранг выполнения (для SEQ равен `0`, для MPI — ранг процесса, сформировавшего выход).

### 2.3. Формальные требования к результату

Для входного массива `A` длины `N` выходной массив `B` должен удовлетворять:
- `|B| = |A|`;
- `B` является перестановкой элементов `A`;
- для всех `i` от `0` до `N-2`: `B[i] <= B[i+1]`.

### 2.4. Ограничения и условия реализации

- Тип данных: `double`.
- Алгоритм сортировки: LSD radix sort.
- Для корректного порядка используется преобразование `double -> uint64_t` и обратное преобразование после сортировки.
- В MPI-версии:
- входной массив распределяется между процессами;
- каждый процесс сортирует свой блок локально;
- итог формируется слиянием отсортированных блоков простым двухпутевым merge.
- Граничные случаи (`N = 0`, `N = 1`, повторяющиеся элементы, отрицательные и положительные значения) должны обрабатываться корректно.

## 3. Базовый алгоритм (последовательный)

Последовательная версия реализует LSD radix sort для `double` через сортировку 64-битных ключей.

### 3.1. Идея

Так как `double` в IEEE 754 не упорядочивается корректно как обычный `uint64_t`, каждый элемент сначала преобразуется в «сортируемый» ключ:
- для отрицательных чисел инвертируются все биты;
- для неотрицательных устанавливается старший бит знака.

После этого ключи можно сортировать как беззнаковые 64-битные значения обычной поразрядной сортировкой по байтам.

### 3.2. Этапы алгоритма

1. Копировать входной массив в рабочий буфер.
2. Для каждого `double` получить `uint64_t`-ключ (`EncodeDoubleKey`).
3. Выполнить 8 проходов counting-sort по байтам (сдвиги `0, 8, 16, ..., 56`):
- подсчитать частоты значений текущего байта (`0..255`);
- вычислить массив стартовых позиций (prefix sums);
- стабильно распределить элементы во временный буфер;
- поменять местами текущий и временный буферы.
4. Преобразовать отсортированные ключи обратно в `double` (`DecodeDoubleKey`).
5. Сохранить результат в выходной контейнер.

### 3.3. Стабильность и корректность

- Каждый байтовый проход выполняется стабильным counting-sort.
- LSD-подход (от младшего байта к старшему) при стабильных проходах гарантирует корректный итоговый порядок.
- Преобразование `double <-> ключ` обеспечивает соответствие лексикографического порядка ключей числовому порядку `double`.

### 3.4. Оценка сложности

Пусть `N` — число элементов, `R = 256` — мощность алфавита байта.

- Временная сложность: `O(8 * (N + R))`, то есть линейная по `N`.
- Память: `O(N)` для временного буфера ключей плюс `O(R)` для счётчиков.

### 3.5. Граничные случаи

- `N = 0` и `N = 1` обрабатываются без специальных ветвлений в логике сортировки (результат остаётся корректным).
- Повторяющиеся значения, отрицательные и положительные числа, дробные значения сортируются корректно за счёт преобразования ключей.

## 4. Схема распараллеливания

### 4.1. Распределение данных между процессами

Пусть:
- `P` — число процессов MPI;
- `N` — размер входного массива.

На процессе `rank = 0` формируются:
- `counts[i]` — сколько элементов получает процесс `i`;
- `displs[i]` — смещение блока процесса `i` во входном массиве.

Распределение равномерное:
- `base = N / P`;
- `extra = N % P`;
- `counts[i] = base + 1`, если `i < extra`, иначе `base`.

Передача выполняется через `MPI_Scatterv`.

### 4.2. Локальные вычисления

Каждый процесс независимо:
1. получает свой локальный блок;
2. выполняет локальную последовательную radix-sort для `double`;
3. участвует в многошаговом слиянии.

### 4.3. Схема связи и слияния (дерево)

Используется иерархическое (binary tree) слияние отсортированных блоков.

На шаге `step = 1, 2, 4, ...`:
- процесс с `rank % (2*step) == 0` принимает данные от `rank + step` (если такой процесс есть) и выполняет простое двухпутевое merge;
- процесс с `rank % (2*step) == step` отправляет свой текущий отсортированный блок процессу `rank - step` и завершает участие.

Итоговый полностью отсортированный массив остаётся на `rank = 0`.

### 4.4. Роли процессов

- `rank 0`: источник входных данных, участник всех необходимых шагов слияния, владелец финального результата.
- `rank > 0`: сортировка своего блока и передача результата согласно шагу дерева слияния.

### 4.5. Краткий псевдокод MPI-части

```text
if rank == 0:
    prepare counts, displs
broadcast N
scatterv input -> local_data
local_radix_sort(local_data)

step = 1
while step < P:
    if rank % (2*step) == 0:
        partner = rank + step
        if partner < P:
            recv partner_data
            local_data = merge(local_data, partner_data)
    else if rank % (2*step) == step:
        send local_data to rank-step
        break
    step *= 2

if rank == 0:
    output = local_data
```

## 5. Детали реализации

### 5.1. Структура кода

Основные файлы задачи:
- `common/include/common.hpp`
- `seq/include/ops_seq.hpp`
- `seq/src/ops_seq.cpp`
- `mpi/include/ops_mpi.hpp`
- `mpi/src/ops_mpi.cpp`
- `tests/functional/main.cpp`
- `tests/performance/main.cpp`

Ключевые типы (`common/include/common.hpp`):
- `InType = std::vector<double>`
- `OutType = std::tuple<std::vector<double>, int>`
- `BaseTask = ppc::task::Task<InType, OutType>`

Вспомогательные функции:
- `EncodeDoubleKey(double)` — преобразование `double` в сортируемый `uint64_t`-ключ;
- `DecodeDoubleKey(uint64_t)` — обратное преобразование ключа в `double`.

Последовательная версия:
- класс `YushkovaPRadixSortWithSimpleMergeSEQ`;
- в `RunImpl()` копируется вход, выполняется локальная поразрядная сортировка (`RadixSortDoubleVector`), результат записывается в выход.

MPI-версия:
- класс `YushkovaPRadixSortWithSimpleMergeMPI`;
- в `RunImpl()`:
  - строится план распределения (`BuildScatterPlan`);
  - данные распределяются через `MPI_Scatterv`;
  - каждый процесс сортирует свой локальный блок;
  - выполняется поэтапное (деревом) слияние через `MPI_Send/MPI_Recv`;
  - итоговый отсортированный массив формируется на процессе `rank = 0`.

Функция слияния:
- `MergeTwoSortedVectors(left, right)` — простое двухпутевое слияние двух отсортированных массивов.

### 5.2. Важные предположения и граничные случаи

Граничные случаи:
- пустой массив (`N = 0`);
- массив из одного элемента;
- повторяющиеся значения;
- смешанные отрицательные/положительные и дробные значения.

Замечание по выходу в MPI:
- содержательный отсортированный вектор формируется на `rank = 0`;
- на остальных рангах выходной вектор может быть пустым, что соответствует схеме задачи.

### 5.3. Вопросы использования памяти

SEQ-версия:
- рабочая копия входа;
- массив ключей `uint64_t`;
- временный буфер для counting-pass;
- дополнительные массивы частот/позиций на `256` корзин.

Итого: асимптотически `O(N)` дополнительной памяти.

MPI-версия:
- каждый процесс хранит локальный блок (`~N/P` в среднем);
- на шагах слияния принимающий процесс дополнительно хранит принятый блок и результат merge;
- процесс `rank = 0` в конце хранит полный отсортированный массив (`O(N)`), что необходимо для выдачи итогового результата.

## 6. Экспериментальная настройка

### 6.1. Аппаратное обеспечение и ОС

- Процессор: Intel(R) Core(TM) i5-11400H @ 2.70GHz
- Ядра/потоки: 6 ядер / 12 потоков
- ОЗУ: ~3.8 GiB (доступно в текущем окружении WSL2)
- ОС: Linux (WSL2), kernel `6.6.87.2-microsoft-standard-WSL2`

### 6.2 Инструментарий

- Компилятор C++: `c++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0`
- MPI: Open MPI `4.1.6`
- Система сборки: CMake
- Тип сборки: `Release`

### 6.4. Тестовые данные

Источник данных:
- функциональные тесты: вручную заданные наборы в  
  `tasks/yushkova_p_radix_sort_with_simple_merge/tests/functional/main.cpp`
- производительный тест: псевдослучайная генерация в  
  `tasks/yushkova_p_radix_sort_with_simple_merge/tests/performance/main.cpp`

Параметры генерации для performance:
- размер массива: `250000`
- генератор: `std::mt19937_64`
- seed: `42`
- распределение: `std::uniform_real_distribution<double>(-10000.0, 10000.0)`

## 7. Результаты и обсуждение

### 7.1 Корректность

Корректность проверялась функциональными тестами и сравнением с эталонной сортировкой `std::sort`:

- для каждого тестового набора строился эталонный результат;
- проверялось совпадение размеров входа/выхода;
- проверялся порядок по неубыванию;
- сравнение значений выполнялось с точностью `1e-12`.

Покрытые случаи:
- смешанные положительные/отрицательные значения;
- дробные значения;
- повторяющиеся элементы;
- пустой массив;
- массив из одного элемента.

Для MPI-версии результат дополнительно проверялся на `rank = 0`.

### 7.2 Производительность

Измерения: 5 запусков для каждого режима, вход `N = 250000`.

Средние времена:
- `seq`: `(0.34 + 0.32 + 0.32 + 0.32 + 0.32)/5 = 0.324 c`
- `mpi, p=1`: `(0.33 + 0.32 + 0.32 + 0.32 + 0.36)/5 = 0.330 c`
- `mpi, p=2`: `(0.35 + 0.35 + 0.34 + 0.34 + 0.33)/5 = 0.342 c`
- `mpi, p=4`: `(0.34 + 0.33 + 0.33 + 0.33 + 0.33)/5 = 0.332 c`

Формулы:
- ускорение: `S_p = T_seq / T_p`
- эффективность: `E_p = (S_p / p) * 100%`

| Режим | Количество | Время, с | Ускорение | Эффективность |
|-------------|-------|---------|---------|-----------|
| seq | 1 | 0.324 | 1.00 | N/A |
| mpi | 1 | 0.330 | 0.98 | 98.2% |
| mpi | 2 | 0.342 | 0.95 | 47.4% |
| mpi | 4 | 0.332 | 0.98 | 24.4% |

Обсуждение:
- на данном стенде заметного ускорения MPI не получено;
- основная причина — для `N=250000` накладные расходы запуска/коммуникаций MPI сопоставимы с временем самой сортировки;

## 8. Выводы

В работе реализована поразрядная сортировка для чисел типа `double` в двух вариантах: последовательном (SEQ) и параллельном (MPI). Для корректного упорядочивания вещественных чисел использовано преобразование `double` в сортируемые `uint64_t`-ключи с последующим обратным преобразованием. В MPI-версии применены распределение данных между процессами, локальная radix-сортировка и простое двухпутевое слияние отсортированных блоков по древовидной схеме.

Функциональные тесты подтвердили корректность реализации для типовых и граничных случаев: пустой массив, один элемент, повторяющиеся значения, смешанные отрицательные и положительные числа, дробные значения.

По результатам измерений на данном стенде (WSL, `N=250000`) устойчивого ускорения MPI относительно SEQ не получено: накладные расходы запуска и межпроцессного обмена сопоставимы с временем вычислений.

Ограничения проведённого исследования:
- сравнительно небольшой размер входных данных для оценки масштабируемости;
- влияние среды выполнения WSL на стабильность и абсолютные времена;
