# Построение выпуклой оболочки — проход Грэхема (MPI)

- Студент: Назарова Ксения Олеговна, группа 3823Б1ПР3  
- Технология: SEQ | MPI  
- Задача: 24

## Введение

Цель работы — реализовать построение выпуклой оболочки множества точек на плоскости последовательным (SEQ) и параллельным (MPI) способами.

## Постановка задачи

Дано множество точек \(\{(x_i, y_i)\}\). Требуется построить выпуклую оболочку — минимальный выпуклый многоугольник, содержащий все точки.

Входные данные:

```cpp
struct Point { int x, y; };
struct Input { std::vector<Point> points; };
```

Выходные данные: вершины выпуклой оболочки **в порядке обхода против часовой стрелки (CCW)** без повторения первой точки.

## Базовый алгоритм (SEQ): Graham scan

Алгоритм:
- выбирается опорная точка (минимальная по \(y\), затем по \(x\));
- остальные точки сортируются по полярному углу относительно опорной (при равном угле — по расстоянию);
- стек/вектор оболочки строится последовательным добавлением точек с удалением последних при правом повороте/коллинеарности.

Сложность: \(O(n \log n)\) по времени (за счёт сортировки), \(O(n)\) по памяти.

## Схема распараллеливания (MPI)

Так как входной набор точек доступен всем процессам в рамках тестового окружения, распараллеливание сделано в два этапа:

1) **Локальная обработка**: каждый процесс берёт свой блок точек и строит локальную оболочку (Graham scan).
2) **Объединение**: локальные оболочки (их вершины) собираются на `rank=0` через `MPI_Gatherv`, на корневом процессе строится итоговая оболочка, затем результат рассылается всем процессам через `MPI_Bcast`.

Замечание: объединение оболочек корректно, потому что глобальная оболочка содержится в оболочке множества кандидатов (вершин локальных оболочек).

## Детали реализации

Файлы реализации:
- SEQ: `tasks/Nazarova_K_Conv_hull_const_Grah/seq/src/ops_seq.cpp`
- MPI: `tasks/Nazarova_K_Conv_hull_const_Grah/mpi/src/ops_mpi.cpp`

## Проверка корректности

Функциональные тесты: `tasks/Nazarova_K_Conv_hull_const_Grah/tests/functional/main.cpp`.

Проверяются:
- пустой ввод и единичная точка;
- квадрат с внутренними точками и дубликатами;
- коллинеарные точки;
- случайные наборы точек (сравнение с эталонной реализацией monotone chain).

## Производительность

Performance-тесты: `tasks/Nazarova_K_Conv_hull_const_Grah/tests/performance/main.cpp`.

В тесте используется \(n=200000\) случайных точек; корректность результата проверяется сравнением с эталонной оболочкой.

Замеры (MPI запуск под `mpirun --oversubscribe -n 2`):

| Mode     | Procs | Time, s      | Speedup | Efficiency |
|----------|------:|-------------:|--------:|-----------:|
| pipeline |     1 | 0.8867654800 | 1.00    | N/A        |
| pipeline |     2 | 0.4245403378 | 2.08    | 104.0%     |
| task_run |     1 | 0.8099996090 | 1.00    | N/A        |
| task_run |     2 | 0.4384538370 | 1.85    | 92.5%      |

Где \(Speedup = T_{seq} / T_{mpi}\), \(Efficiency = Speedup / p\).

## Как воспроизвести

Сборка:

```bash
git submodule update --init --recursive
cmake -S . -B build -D USE_FUNC_TESTS=ON -D USE_PERF_TESTS=ON -D CMAKE_BUILD_TYPE=Release
cmake --build build --config Release --parallel
```

Функциональные тесты:

```bash
./build/bin/ppc_func_tests --gtest_filter='*ConvHullGrahamTests*'
```

Performance-тесты (MPI часть под `mpirun`):

```bash
export OMPI_ALLOW_RUN_AS_ROOT=1
export OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1
mpirun --oversubscribe -n 2 ./build/bin/ppc_perf_tests --gtest_filter='*Conv_hull_const_Grah*'
```

## Заключение

Реализованы SEQ и MPI версии построения выпуклой оболочки методом Грэхема; MPI-версия использует схему «локальная оболочка → сбор кандидатов → итоговая оболочка на корневом процессе → рассылка результата».
