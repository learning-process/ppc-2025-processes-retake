# Построение выпуклой оболочки — проход Грэхема

- Студент: Дилшодов Адхам Умидович, группа 3823Б1ПР4
- Технология: SEQ + MPI
- Вариант: Построение выпуклой оболочки (алгоритм Грэхема) для изображения

## 1. Введение

Построение выпуклой оболочки множества точек — одна из базовых задач
вычислительной геометрии, которая широко применяется в компьютерной графике,
обработке изображений, распознавании образов и геоинформационных системах.

Выпуклая оболочка — минимальный выпуклый многоугольник, содержащий все
заданные точки. Алгоритм Грэхема (модификация Andrew's monotone chain)
решает эту задачу путём сортировки точек и последовательного построения
верхней и нижней цепей оболочки с использованием стека.

В данной работе изображение задаётся в виде одномерного массива
(оттенки серого), из которого извлекаются координаты ненулевых пикселей
как точки на плоскости. Для полученного множества точек строится
выпуклая оболочка.

Цель работы — реализовать последовательную и параллельную версии
алгоритма, провести тестирование и проанализировать эффективность
распараллеливания.

## 2. Постановка задачи

**Входные данные:** одномерный массив целых чисел
`std::vector<int>`, в котором первые два элемента — ширина (W)
и высота (H) изображения, а остальные W×H элементов —
значения пикселей (0 = фон, ≠0 = объект).

**Выходные данные:** вектор точек `std::vector<Point>` — вершины выпуклой оболочки.

**Ограничения:**

- W, H > 0, размер массива = W × H + 2
- Если количество уникальных ненулевых точек < 3, или все точки коллинеарны — результат пустой
- Коллинеарные точки корректно обрабатываются

## 3. Базовый алгоритм (последовательный)

Последовательная версия состоит из двух этапов:

1. **Извлечение точек:** линейный проход по массиву пикселей, перевод ненулевых элементов в координаты `(x, y)`.
2. **Построение оболочки (Andrew's monotone chain):**
   - Сортировка точек по `x` (при равенстве — по `y`)
   - Удаление дубликатов
   - Построение нижней цепи с удалением точек, нарушающих выпуклость
   - Построение верхней цепи аналогично в обратном порядке
   - Объединение цепей

```cpp
std::vector<Point> GrahamScan(std::vector<Point> pts) {
  std::ranges::sort(pts, PointLess);
  pts.erase(std::ranges::unique(pts).begin(), pts.end());

  std::vector<Point> hull;
  for (const auto &p : pts) {
    while (hull.size() >= 2 && Cross(hull[hull.size() - 2], hull.back(), p) <= 0)
      hull.pop_back();
    hull.push_back(p);
  }

  auto lower_size = hull.size();
  for (int i = static_cast<int>(pts.size()) - 2; i >= 0; --i) {
    const auto &p = pts[i];
    while (hull.size() > lower_size && Cross(hull[hull.size() - 2], hull.back(), p) <= 0)
      hull.pop_back();
    hull.push_back(p);
  }
  hull.pop_back();
  return hull;
}
```

**Сложность:** O(N log N) — доминирует сортировка, где N — количество ненулевых пикселей.

## 4. Схема распараллеливания

Используется схема декомпозиции данных с финальным объединением:

1. **Broadcast параметров:** rank 0 рассылает ширину и высоту изображения всем процессам (`MPI_Bcast`)
2. **Распределение пикселей (MPI_Scatterv):** одномерный массив пикселей делится на примерно равные блоки
3. **Локальная обработка:** каждый процесс извлекает точки из своего
   блока (с учётом глобального смещения для корректных координат)
   и строит локальную выпуклую оболочку
4. **Сбор результатов (MPI_Gatherv):** вершины локальных оболочек собираются на rank 0
5. **Финальное объединение:** rank 0 строит итоговую выпуклую оболочку из объединённых локальных вершин

### Балансировка нагрузки

```cpp
int base = n / size;
int rem = n % size;
sendcounts[i] = base + (i < rem ? 1 : 0);
```

## 5. Используемые функции MPI

- **MPI_Comm_rank** — получение номера текущего процесса
- **MPI_Comm_size** — получение общего количества процессов
- **MPI_Bcast** — широковещательная рассылка размеров изображения
- **MPI_Scatterv** — распределение массива пикселей между процессами
- **MPI_Gather** — сбор размеров локальных оболочек
- **MPI_Gatherv** — сбор вершин локальных оболочек на rank 0
- **MPI_Type_contiguous** — создание MPI-типа для структуры Point (2 × MPI_INT)

## 6. Экспериментальная установка

| Параметр | Значение |
| ---------- | ----------------------------------------------------- |
| CPU | AMD Ryzen 5 5600 (6 ядер / 12 потоков) @ 3.693 GHz |
| RAM | 32 ГБ |
| ОС | Windows 11 + WSL2 (Ubuntu 24.04.2 LTS) |
| Компилятор | GCC (g++) |
| MPI | Open MPI |
| Тип сборки | Release |

### Тестовые данные

- Изображение: **1000 × 1000** (1 000 000 пикселей), полностью заполненное
- Ожидаемая оболочка: 4 угловые точки

## 7. Результаты

### 7.1 Корректность

Все 16 функциональных тестов проходят успешно:

- Квадрат с внутренней точкой (5×5)
- Треугольник (3×3)
- Разреженные точки (10×10)
- Прямоугольная рамка (10×10)
- Коллинеарные точки (5×5) → пустой результат
- Одиночная точка (5×5) → пустой результат
- Большой квадрат (20×20)
- Полностью заполненный квадрат (50×50)

### 7.2 Производительность

| Режим | Процессы | Время, мс | Speedup | Efficiency |
| ----- | -------- | --------- | ------- | ---------- |
| SEQ   | 1        | 97        | —       | —          |
| MPI   | 1        | 113       | 1.00    | 100%       |
| MPI   | 2        | 51        | 2.22    | 111%       |
| MPI   | 4        | 26        | 4.35    | 108.7%     |
| MPI   | 6        | 26        | 4.35    | 72.5%      |

### 7.3 Профилирование MPI (4 процесса)

| Операция                        | Время, мс | Доля |
| ------------------------------- | --------- | ---- |
| MPI_Bcast (размеры)             | 0.004     | 0%   |
| MPI_Scatterv (пиксели)          | 1.3       | 5%   |
| Извлечение точек                | 0.7       | 3%   |
| Локальная оболочка (GrahamScan) | 22.7      | 88%  |
| MPI_Gatherv (сбор оболочек)     | 0.6       | 2%   |
| Финальная оболочка (rank 0)     | 0.001     | 0%   |
| **Итого**                       | **25.3**  | 100% |

**Вывод из профилирования:** 88% времени занимает построение
локальной выпуклой оболочки (сортировка + обход), лишь ~10% —
коммуникации (Scatterv + Gatherv). Алгоритм хорошо масштабируется,
так как основная вычислительная нагрузка распределяется
между процессами.

## 8. Выводы

В ходе работы реализованы последовательная и параллельная версии
построения выпуклой оболочки из изображения методом Грэхема.
Обе версии успешно проходят функциональные тесты.

Параллельная MPI версия демонстрирует ускорение относительно
себя же с одним процессом: при 4 процессах достигается
speedup 4.35x. Суперлинейное ускорение при 2–4 процессах
связано с эффектом кэша — каждый процесс обрабатывает
меньший объём данных, который лучше помещается в L2/L3.

При 6 процессах время не уменьшается по сравнению с 4 —
начинают доминировать накладные расходы на коммуникацию.
Профилирование показало, что 88% времени — полезные
вычисления (построение локальной оболочки),
лишь ~10% — передача данных.

## 9. Источники

1. Сысоев А. В. Лекции курса «Параллельное программирование для кластерных систем»
2. Документация лабораторных работ — <https://learning-process.github.io/parallel_programming_course/ru>

## Приложение

### Последовательная версия

```cpp
bool ConvexHullSEQ::RunImpl() {
  const auto &input = GetInput();
  std::vector<int> pixels(input.begin() + 2, input.end());

  auto pts = ExtractPoints(pixels, width_, height_);
  GetOutput() = GrahamScan(std::move(pts));
  return true;
}
```

### MPI версия (ключевой фрагмент)

```cpp
// Распределение пикселей между процессами
MPI_Scatterv(pixels.data(), sendcounts.data(), displs.data(), MPI_INT,
             local_pixels.data(), local_n, MPI_INT, 0, MPI_COMM_WORLD);

// Извлечение точек из локального блока с учётом глобального смещения
for (int i = 0; i < local_pixels.size(); ++i) {
  if (local_pixels[i] != 0) {
    int global_idx = global_offset + i;
    local_points.push_back({global_idx % width_, global_idx / width_});
  }
}

// Построение локальной оболочки
GrahamScanInPlace(local_points);

// Сбор локальных оболочек и финальное объединение
MPI_Gatherv(local_hull.data(), local_size, mpi_point,
            gathered.data(), recv_sizes.data(), displs_hull.data(),
            mpi_point, 0, MPI_COMM_WORLD);
GrahamScanInPlace(gathered);  // Финальная оболочка
```
