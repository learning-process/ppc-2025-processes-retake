# Нахождение максимальных значений по столбцам матрицы

-   **Студент**: Камалетдинов Рамзан Рамилевич, группа 3823Б1ПР4
-   **Технология**: SEQ | MPI
-   **Вариант**: 16

## 1. Введение

Матрицы - это фундаментальная структура данных, широко используемая в научных вычислениях.

Цель моей работы - реализовать алгоритм поиска максимальных элементов по столбцам матрицы, распараллелить его при помощи технологии MPI для ускорения обработки больших матриц.

## 2. Постановка задачи

Дана матрица размером `m × n`

Требуется найти максимальный элемент в каждой строке матрицы.

Тип входных данных:

```cpp
using InType = std::tuple<std::size_t, std::size_t, std::vector<int>>;
```

Тип выходных данных:

```cpp
using OutType = std::vector<int>;
```

Ограничения:

-   Матрица должна быть непустой (m > 0, n > 0)
-   Элементы матрицы целочисленные

## 3. Базовый алгоритм (последовательная версия)

Для удобства работы с индексам и возможных оптимизаций при помощи векторизации, перед началом работы входящая матрица транспонируется.

Алгоритм нахождения максимальных значений по **столбцам** матрицы превращается в нахождения максимальных значений по **строкам** матрицы.

Алгоритм:

-   выделяется вектор размером `n` для сохранения результата каждой строки
-   начинается стандратный цикл обхода всех элементов матрицы
    -   внешний цикл(i от 0 до `n`): инициализирует начальное значение в векторе результата для i-ой строки матрицы
    -   внутренний цикл (j от 0 до `m`):
        -   сравнение конкретного элемента строки с вектором результата
        -   если элемент оказался больше, то значение вектора заменяется на значение элемента

Код алгоритма:

```cpp
std::vector<int> max_rows_elem(n);
for(std::size_t i = 0; i < n; i++) {
  max_rows_elem[i] = t_matrix_[i * m];
  for(std::size_t j = 1; j < m; j++) {
    if(max_rows_elem[i] < t_matrix_[i * m + j]){
      max_rows_elem[i] = t_matrix_[i * m + j];
    }
  }
}
```

**Характеристики:**

| Параметр             | Значение |
| -------------------- | -------- |
| Сложность по времени | O(m x n) |
| Сложность по памяти  | O(n)     |

## 4. Схема распараллеливания

Расспараллеливание алгоритма организовано схемой распараллеливания по данным.
Исходная матрица, представленная в виде вектора, разбивается поровну между всеми процессами.

Распределение данных происходит по следующему алгоритму.
**Код**

```cpp
int rank = 0;
int mpi_size = 0;
MPI_Comm_rank(MPI_COMM_WORLD, &rank);
MPI_Comm_size(MPI_COMM_WORLD, &mpi_size);
//рассчет части матрицы для обработки процессом
std::size_t procesess_step = t_matrix_.size() / mpi_size;
std::size_t start = procesess_step * rank;
std::size_t end = procesess_step * (rank + 1);
if (rank == mpi_size - 1) {
  end = t_matrix_.size();
}
```

Кажддый процесс выполняет подсчет на своем участке:

```cpp
//выделение памяти для сохранения максимального элемента
std::vector<int> max_rows_elem;
if(rank == 0) {
  max_rows_elem.resize(n * mpi_size, 0);
} else {
  max_rows_elem.resize(n, 0);
}
std::size_t row = start / m;
max_rows_elem[row] = t_matrix_[start];
for(std::size_t i = start; i < end; i++) {
  if(i == (row + 1) * m) {
    row++;
    max_rows_elem[row] = t_matrix_[i];
  }
  if(max_rows_elem[row] < t_matrix_[i]) {
    max_rows_elem[row] = t_matrix_[i];
  }
}
```

Отличия параллельной версии:

-   память выделяется неодинаково на каждом процессе. Так как процесс с ранком 0 будет собирать полученные результаты со всех процессов, то размер вектора результата (`max_rows_elem`) больще остальных.
-   Параллельный алгоритм дополнительно рассчитывает номер строки, с которой начинается его обход по элементам матрицы, чтобы корректно записывать данные в вектор результата.
-   В цикле ушла вложенность, обход происходит прямиком по индексам
-   Для опредление строки матрицы внутрь цикла добавлено условие перехода

### Получение результата

`MPI_Gather()` - собирает частичные результаты со всех процессов на процессе с ранком 0.
**Код**

```cpp
MPI_Gather(max_rows_elem.data(), n, MPI_INT, max_rows_elem.data(), n, MPI_INT, 0, MPI_COMM_WORLD);
```

На процессе с ранком 0 происходит объединение результатов:
**Код**

```cpp
if(rank == 0) {
  for(std::size_t i = 0; i < n; i++) {
    for(int j = 0; j < mpi_size; j++) {
      if(max_rows_elem[i] < max_rows_elem[j * n + i]) {
        max_rows_elem[i] = max_rows_elem[j * n + i];
      }
    }
  }
}
```

Полученный результат процесс с раном 0 отправляет всем остальным процессам при помощи вызова `MPI_Bcast()`.
**Код**

```cpp
MPI_Bcast(max_rows_elem.data(), n, MPI_INT, 0, MPI_COMM_WORLD);
```

### Схема работы программы

```
┌──────────────────────────────┐
│  Mатрица M x N               │
└────────┬─────────────────────┘
         │ (транспонирование матрицы)
         ↓
┌──────────────────────────────────┐
│  Транспонированная матрица N x M │
└────────┬─────────────────────────┘
         │ (распределение данных)
         ↓
 ┌─────────────────┬─────────────────┬─────────────────┐
 │  Процесс 0      │  Процесс 1      │  Процесс 2      │
 │ start(0), end(0)│ start(1), end(1)│ start(2), end(2)│
 └───────┬─────────┴─────────────────┴─────────────────┘
         │ (локальный поиск максимумов)
         ↓
 ┌───────────────────┬─────────────────────┬────────────────────┐
 │ local_vec_max(0)  │  local_vec_max(1)   │  local_vec_max(2)  │
 └───────┬───────────┴─────────────────────┴────────────────────┘
         │ MPI_Gather
         ↓
┌───────────────────────────────────────┐
│  Процесс 0 собирает все local_vec_max │
└────────┬──────────────────────────────┘
         │ (объединение результатов)
         ↓
┌───────────────────────────────────────┐
│  Процесс 0 вычисляет global_vec_max   │
└────────┬──────────────────────────────┘
         │ MPI_Bcast
         ↓
┌─────────────────────────────────────────────────┐
│   Все процессы получают итоговые максимумы      │
│  Сохранение: GetOutput() = global_vec_max       │
└─────────────────────────────────────────────────┘
```

## 5. Детали реализации

**Структура проекта**
| Файл | Назначение |
|------------------------|---------------------------------------------|
| `common.hpp` | Определение входных и выходных типов задачи |
| `ops_seq.hpp/.cpp` | Последовательная реализация |
| `ops_mpi.hpp/.cpp` | MPI-реализация |
| `functional/main.cpp` | Функциональные тесты |
| `performance/main.cpp` | Тестирование производительности |

**Особенности реализации**

-   Матрица предварительно транспонируется для более эффективного доступа к строкам

## 6. Экспериментальная среда

| Компонент  | Значение                                |
| ---------- | --------------------------------------- |
| CPU        | Apple M2 (8 cores)                      |
| RAM        | 16 GB                                   |
| ОС         | OS: Ubuntu 24.04 (DevContainer / macOs) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release |
| MPI        | mpirun (Open MPI) 4.1.6                 |

Тестовые данные:

-   Данные из файла в формате:
    -   первая строка из двух чисел - размера матрицы (`m` `n`)
    -   остальные строки - значение элементов матрицы
-   Сгенерированные матрицы рзаличных размеров
    Для генерации случайных чисел было использована библиотека `<random>`.

## 7. Результаты и обсуждение

### 7.1 Корректность

Функциональные тесты используют как предопределенные входные файлы, так и сгенерированные данные.
Струкутра параметра теста:

-   строка: имя теста
-   строка: путь к файлу или указание на генерацию
-   целочисленный вектор:результат

Тесты включают проверку:

-   Матрицы 3×3 с последовательными значениями
-   Матриц различных размеров со случайными значениями
-   Корректности вычисления максимальных элементов

Обе реализации (`SEQ`, `MPI`) прошли тесты успешно.

### 7.2 Производительность

Рассчет производительности производился на сгененрированной матрице размером 10000 на 10000, с сидом генерации 123.

| Mode | Count | Time, s | Speedup | Efficiency |
| ---- | ----- | ------- | ------- | ---------- |
| seq  | 1     | 0.0642  | 1.00    | N/A        |
| omp  | 2     | 0.0325  | 1.98    | 98%        |
| omp  | 4     | 0.0225  | 2.83    | 70.75%     |

## 8. Заключение

В ходе выполнения работы мне пришлось:

-   реализовать алгоритм нахождения максимальных значений по столбцам матрицы
-   распараллелить его при помощи MPI
-   разработать систему тестирования для проверки корректности реализации
-   провести измерения производительности и рассчитать характеристики ускорения и эффективности

## 9. Источники

## Приложение

Код транспонирования матрицы:

```cpp
std::size_t m = std::get<0>(GetInput());
std::size_t n = std::get<1>(GetInput());
std::vector<int> &val = std::get<2>(GetInput());
t_matrix_ = std::vector<int>(n * m);
for(std::size_t i = 0; i < m; i++) {
  for(std::size_t j = 0; j < n; j++) {
    t_matrix_[(j * m) + i] = val[(i * n) + j];
  }
}
```

Код генерации тестовых данных

```cpp
void Generate(std::size_t m, std::size_t n, int seed) {
  std::mt19937 gen(seed);
  std::uniform_int_distribution<> idis(-10, 20);
  std::vector<int> val(m * n);
  std::vector<int> answer(n);
  // задание начальных значений для ответа
  // первая строка матрицы задает максимальные значнечения для элементов столбцов
  for (std::size_t i = 0; i < n; i++) {
    val[i] = idis(gen);
    answer[i] = val[i];
  }
  // генерация остальной матрицы, вектора ответа
  for (std::size_t i = 1; i < m; i++) {
    for (std::size_t j = 0; j < n; j++) {
      val[i * n + j] = idis(gen);
      if (answer[j] < val[i * n + j]) {
        answer[j] = val[i * n + j];
      }
    }
  }
  input_data_ = std::make_tuple(m, n, val);
  correct_test_output_data_ = answer;
}
```
