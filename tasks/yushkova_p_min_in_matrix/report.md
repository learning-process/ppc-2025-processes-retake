# Нахождение минимальных значений по строкам матрицы

- Student: Юшкова Полина Александровна, group 3823Б1ПР2
- Technology: SEQ + MPI
- Variant: 17

## 1. Введение
В лабораторной работе реализована задача поиска минимальных значений по строкам квадратной
матрицы размера `N x N`. Практическая значимость задачи связана с обработкой больших объёмов
данных, где полный массив может занимать значительный объём памяти. Поэтому матрица в работе
не хранится целиком: элементы вычисляются детерминированно по индексам строки и столбца.

## 2. Постановка задачи
Требуется для заданного целого числа `N > 0` вычислить вектор минимумов по строкам квадратной матрицы размера `N x N`.

Значение элемента матрицы определяется детерминированной функцией:
`A[i][j] = generate_value(i, j)`, где `i, j ∈ [0, N-1]`.

Искомый результат:
`out[i] = min(A[i][j])` по всем `j` от `0` до `N-1`.

Формат ввода:
- одно целое число `N`.

Формат вывода:
- вектор `out` длины `N`, где каждый элемент — минимум соответствующей строки.

Ограничения:
- `N` должно быть строго положительным (`N > 0`);
- при `N <= 0` задача считается невалидной;
- реализации SEQ и MPI должны формировать одинаковый результат для одинакового `N`.

## 3. Базовый алгоритм (последовательный)
Последовательная версия решает задачу полным перебором элементов каждой строки без хранения всей матрицы в памяти.

Алгоритм:
1. Принять входной параметр `N`.
2. Проверить корректность входа: если `N <= 0`, выполнение прекращается с ошибкой валидации.
3. Подготовить выходной вектор `out` размера `N`.
4. Для каждой строки `i` от `0` до `N - 1`:
   - вычислить начальное значение минимума
     `row_min = generate_value(i, 0)`;
   - для каждого столбца `j` от `1` до `N - 1`:
     - вычислить `val = generate_value(i, j)`;
     - обновить минимум: `row_min = min(row_min, val)`;
   - записать результат в `out[i] = row_min`.
5. После завершения цикла вернуть `out`.

Ключевые особенности:
- матрица `N x N` не создаётся в памяти;
- значения элементов вычисляются по ходу алгоритма;
- результат полностью детерминирован для фиксированного `N`.

Оценка сложности:
- временная сложность: `O(N^2)`;
- дополнительная память: `O(N)` (только выходной вектор и несколько служебных переменных).

## 4. Схема распараллеливания

В работе реализована MPI-версия с разбиением по строкам матрицы.

### Распределение данных (MPI)

Пусть:
- `P` — число процессов (`world_size`),
- `r` — ранг процесса (`rank`),
- `N` — размер матрицы.

Сначала вычисляются:
- `base_rows = N / P`,
- `extra = N % P`.

Тогда процесс `r` получает:
- `my_count = base_rows + (r < extra ? 1 : 0)`,
- `my_start = (r * base_rows) + min(r, extra)`.

То есть первые `extra` процессов получают на одну строку больше, что обеспечивает
балансировку нагрузки (разница между процессами не более 1 строки).

### Роли рангов

Все ранги равноправны:
- каждый процесс считает минимумы только для своего диапазона строк;
- затем все процессы участвуют в коллективном обмене и получают полный итоговый вектор.

Отдельного мастер-процесса для сборки результата не требуется, так как используется `MPI_Allgatherv`.

### Схема связи

Топология — стандартный коммуникатор `MPI_COMM_WORLD`.

Обмен:
1. Каждый ранг формирует `local_results` длины `my_count`.
2. На всех рангах строятся одинаковые массивы:
   - `recv_counts[i]` — сколько элементов присылает процесс `i`,
   - `offsets[i]` — смещение данных процесса `i` в итоговом векторе.
3. Вызов `MPI_Allgatherv(...)` собирает локальные части в общий `out` на каждом ранге.

## 5. Детали реализации

### 5.1 Структура кода

Основные файлы задачи:
- `common/include/common.hpp` — общие типы (`InType`, `OutType`, `BaseTask`).
- `seq/include/ops_seq.hpp`, `seq/src/ops_seq.cpp` — последовательная реализация `YushkovaPMinInMatrixSEQ`.
- `mpi/include/ops_mpi.hpp`, `mpi/src/ops_mpi.cpp` — MPI-реализация `YushkovaPMinInMatrixMPI`.
- `tests/functional/main.cpp` — функциональные тесты (корректность, валидация, повторный запуск).
- `tests/performance/main.cpp` — тесты производительности (pipeline/task для SEQ и MPI).

Ключевые функции:
- `GenerateValue(i, j)` — детерминированная генерация элемента виртуальной матрицы.
- `ValidationImpl()` — проверка корректности входа.
- `PreProcessingImpl()` — подготовка выходного буфера.
- `RunImpl()` — основная вычислительная логика (SEQ или MPI).
- `PostProcessingImpl()` — финальная проверка результата.

### 5.2 Важные предположения и граничные случаи

Предположения:
- входной параметр `N` должен быть целым и положительным;
- генератор `GenerateValue` одинаков по логике в SEQ/MPI/тестах;
- MPI-коммуникатор — `MPI_COMM_WORLD`.

Граничные случаи:
- `N <= 0` — задача невалидна (валидация возвращает `false`);
- `N < P` (процессов больше, чем строк) — часть рангов получает `my_count = 0`,
  но программа работает корректно за счёт `MPI_Allgatherv`;
- `N = 1` — корректно обрабатывается как минимальный допустимый размер.

### 5.3 Использование памяти

- Полная матрица `N x N` в памяти не создаётся.
- В SEQ хранится только выходной вектор `out` (`O(N)`).
- В MPI дополнительно хранится локальный вектор `local_results` размера `my_count`,
  а также служебные массивы `recv_counts` и `offsets` размера `P`.
- Итоговая асимптотика по памяти остаётся линейной относительно `N` (плюс небольшой служебный `O(P)` в MPI).

## 6. Экспериментальная настройка

### 6.1 Аппаратное обеспечение и ОС
- Процессор: Intel(R) Core(TM) i5-11400H @ 2.70GHz
- Ядра/потоки: 6 ядер / 12 потоков
- ОЗУ: ~3.8 GiB (доступно в текущем окружении WSL2)
- ОС: Linux (WSL2), kernel `6.6.87.2-microsoft-standard-WSL2`

### 6.2 Инструментарий
- Компилятор C++: `c++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0`
- MPI: Open MPI `4.1.6`
- Система сборки: CMake
- Тип сборки: `Release`

### 6.3 Окружение запуска
- MPI-запуски выполнялись через:
  - `mpirun -n <1/4/8> ./ppc_?_tests`
  - `./ppc_?_tests`

### 6.4 Данные
- Внешние файлы данных не используются.
- Все элементы матрицы генерируются детерминированной функцией `GenerateValue(i, j)` в:
  - `seq/src/ops_seq.cpp`
  - `mpi/src/ops_mpi.cpp`
  - `tests/functional/main.cpp`
  - `tests/performance/main.cpp`
- Функциональные тесты проверяют размеры `N = {1, 5, 17, 64, 128, 256}`.
- Тесты производительности выполняются для `N = 512`.

## 7. Результаты и обсуждение

### 7.1 Корректность

Корректность проверялась функциональными тестами в `tests/functional/main.cpp`:

- сравнение результата SEQ и MPI с эталонным вектором, пересчитанным
  тем же детерминированным генератором `GenerateValue(i, j)`;
- проверка набора размеров `N = {1, 5, 17, 64, 128, 256}`;
- проверка валидации невалидного входа (`N = 0`);
- проверка повторного использования задач (pipeline reusability) для SEQ и MPI.

Инварианты проверки:
- размер выходного вектора равен `N`;
- каждый элемент `out[i]` равен минимуму по соответствующей строке виртуальной матрицы;
- для одинакового `N` результаты SEQ и MPI совпадают.

По итогам запусков функциональные тесты для задачи проходят успешно.

### 7.2 Производительность

Производительность оценивалась в `tests/performance/main.cpp` в четырёх режимах:
- `SeqPipelineRun`
- `SeqTaskRun`
- `MpiPipelineRun`
- `MpiTaskRun`

Параметры:
- размер задачи: `N = 512`;
- число повторов: `num_running = 3`;
- для MPI: запуск с `mpirun --oversubscribe -n 8 ./ppc_perf_tests`.

Ниже таблица для фиксации итоговых измерений:

| Режим | Количество процессов | Время, с | Ускорение | Эффективность |
| --- | ---: | ---: | ---: | ---: |
| seq pipeline | 1 | 0.0003336943 | 1.00 | N/A |
| seq task | 1 | 0.0003669810 | 1.00 | N/A |
| mpi pipeline | 8 | 0.0002130280 | 1.57 | 19.58% |
| mpi task | 8 | 0.0001784463 | 2.06 | 25.71% |

Формулы:
- `Ускорение = T_seq / T_par`
- `Эффективность = Ускорение / P * 100%`, где `P` — число процессов.

Обсуждение:
- для малых `N` преимущество MPI ограничивается накладными расходами на обмен (`MPI_Allgatherv`);
- при росте `N` доля вычислений увеличивается, и MPI-версия обычно даёт лучший выигрыш;

## 8. Выводы
Реализованы и проверены две версии алгоритма:
- последовательная базовая версия `O(N^2)`;
- MPI-версия с разбиением по строкам, балансировкой нагрузки и `MPI_Allgatherv`.

Решение детерминированное, эффективно по памяти (`O(N)`), покрыто функциональными
и производительными тестами.

## 9. Источники
1. MPI Forum. MPI: A Message-Passing Interface Standard. https://www.mpi-forum.org/docs/
2. Open MPI Documentation. https://docs.open-mpi.org/
