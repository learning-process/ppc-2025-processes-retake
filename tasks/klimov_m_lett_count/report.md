# Подсчет числа буквенных символов в строке

- **Студент**: Климов Михаил Дмитриевич, группа 3823Б1ПР2
- **Технология**: MPI / SEQ
- **Вариант**: 22

## 1. Введение
Цель задачи – разработать параллельную версию программы для подсчета количества буквенных символов (латиница) в заданной строке с использованием MPI, а также последовательную реализацию для сравнения корректности. Программа должна корректно обрабатывать строки произвольной длины, содержащие любые символы.

## 2. Постановка задачи
На вход подается строка произвольной длины. Необходимо подсчитать общее количество символов, для которых функция `std::isalpha()` возвращает истину (латинские буквы). Выходные данные – целое число (количество букв). Корректность работы проверяется на наборе функциональных тестов, включающих граничные случаи: пустая строка, строка без букв, строка из одних букв, смешанные строки, кириллица (не должна засчитываться).

## 3. Описание последовательного алгоритма
Последовательная версия (SEQ) реализована в классе `KlimovMLettCountSEQ`. Алгоритм:
1. Получить входную строку через `GetInput()`.
2. Пройти по каждому символу строки.
3. Для каждого символа проверить, является ли он буквой с помощью `std::isalpha()`.
4. Увеличить счётчик, если условие истинно.
5. Записать итоговое значение в `GetOutput()`.

Алгоритм имеет линейную сложность O(n), где n – длина строки.

## 4. Схема распараллеливания (MPI)
Параллельная версия (MPI) реализована в классе `KlimovMLettCountMPI`. Используется декомпозиция данных по принципу «владелец вычисляет»:
- Процесс с рангом 0 разбивает исходную строку на примерно равные части. Количество частей равно числу процессов `numProcs_`.
- Для учёта остатка от деления используется стандартный подход: первые `remainder` процессов получают на один символ больше.
- Процесс 0 рассылает каждому процессу размер его части (через `MPI_Send`) и затем сами данные (через `MPI_Send`).
- Остальные процессы принимают размер и данные с помощью `MPI_Recv`.
- Каждый процесс вычисляет количество букв в своей локальной части, используя ту же функцию `CountLettersInSegment`.
- Результаты собираются на процессе 0 через `MPI_Reduce` с операцией суммирования.
- Итоговое значение рассылается всем процессам через `MPI_Bcast` (для единообразия).
- В конце выполняется `MPI_Barrier` для синхронизации.

Такая схема минимизирует объём передаваемых данных и равномерно распределяет нагрузку.

## 5. Детали реализации
- В MPI-версии для разбиения строки используются только точечные коммуникации (`MPI_Send`/`MPI_Recv`), что соответствует требованиям варианта (использование только `Send`/`Recv`).
- Подсчёт букв вынесен в отдельную статическую функцию `CountLettersInSegment`, что улучшает читаемость и избегает дублирования кода.
- Валидация входных данных минимальна: проверяется, что число процессов больше нуля.
- Последовательная версия также использует вспомогательную функцию `CountLettersInString`.

## 6. Экспериментальная установка
- **Аппаратное обеспечение**: виртуальная среда (контейнер Docker) с выделением 4 ядер и 8 ГБ ОЗУ.
- **ОС**: Ubuntu 24.04 LTS (внутри контейнера).
- **Компилятор**: g++-14.
- **Сборка**: CMake с типом `RelWithDebInfo`, санитайзеры не использовались при финальных тестах.
- **Среда выполнения**: MPI-тесты запускались с `PPC_NUM_PROC=2` и `PPC_NUM_PROC=4` через скрипт `scripts/run_tests.py`.

## 7. Результаты и обсуждение

### 7.1 Корректность
Для проверки корректности использовался набор из 20 функциональных тестов, включающих:
- пустую строку;
- строки, состоящие только из букв;
- строки, состоящие только из цифр и знаков препинания;
- смешанные строки (буквы + цифры);
- строки с кириллицей (ожидается 0);
- длинные строки (до 100 букв);
- автоматически генерируемую строку с заданным количеством букв.

Все тесты успешно проходятся как для последовательной, так и для MPI-версии при запуске с 2 и 4 процессами. Это подтверждает корректность реализации и отсутствие ошибок, связанных с разбиением данных и межпроцессным взаимодействием.

## 8. Выводы
Разработана параллельная MPI-программа для подсчёта букв в строке, а также её последовательный аналог. Реализация корректно обрабатывает различные входные данные и успешно проходит все функциональные тесты. Использование MPI позволяет распределить вычисления между несколькими процессами, что потенциально даёт выигрыш во времени на больших строках. Дальнейшая оптимизация может включать использование коллективных операций вместо точечных, однако текущая версия полностью соответствует требованиям задачи.

## 9. Источники
1. Microsoft MPI : документация [Электронный ресурс] // Microsoft Learn. – URL: https://learn.microsoft.com/ru-ru/message-passing-interface/microsoft-mpi (дата обращения: 20.11.2025).
2. Сысоев А. В. Курс лекций по параллельному программированию