#  Итерационный метод Зейделя

- Студент: Савва Дария Александровна, 3823Б1ФИ1   
- Технологии: SEQ | MPI 
- Вариант: 19

## 1. Введение
Целью данной лабораторной работы является реализация и исследование итерационного метода Зейделя для решения систем линейных уравнений.  
В работе рассматриваются две реализации алгоритма: последовательная (SEQ) и параллельная (MPI), а также проверяется их корректность и измеряется производительность.  
Особое внимание уделяется анализу ускорения параллельной версии на многопроцессорной системе и оценке эффективности распределения вычислений между процессами.
## 2. Постановка задачи
Необходимо решить систему линейных уравнений вида:

A · x = b,

где:

- A — квадратная матрица размера n,
- x — вектор неизвестных длины n,
- b — вектор свободных членов длины n.

Требуется:

1. Реализовать **последовательный** алгоритм метода Зейделя для нахождения решения $x$.  
2. Реализовать **параллельную** версию алгоритма с распределением вычислений по процессам (MPI).  
3. Проверить корректность обеих реализаций с помощью функциональных тестов.  
4. Измерить время выполнения и вычислить ускорение параллельной версии на многопроцессорной системе.

**Ограничения и требования:**

- Матрица $A$ должна удовлетворять условию диагонального преобладания, чтобы гарантировать сходимость метода.    
- Максимальное количество итераций и точность решения фиксируются в алгоритме.

## 3. Описание линейного алгоритма

**Последовательная реализация метода Зейделя** выполняется следующим образом:

1. Инициализация начального вектора решения $x^{(0)}\$ нулями.
2. Определение максимального числа итераций `max_iter` и точности `eps` для сходимости.
3. Для каждой итерации $k = 1, 2, \dots,$ max_iter:
   - Для каждого уравнения $i = 0 \dots n-1$ вычисляется новое значение $x_i^{(k)}$ по формуле:
     
     $x_i^{(k)} = \frac{b_i - \sum_{j=0}^{i-1} a_{ij} x_j^{(k)} - \sum_{j=i+1}^{n-1} a_{ij} x_j^{(k-1)}}{a_{ii}}$

   - Вычисляется **максимальная ошибка** на итерации `max_error` по формуле:

$$
 \max_i \lvert x_i^{(k)} - x_i^{(k-1)} \rvert
$$


   - Если `max_error < eps`, процесс итераций прекращается.
5. После завершения итераций возвращается вектор $x$ как решение системы.

**Особенности метода:**

- Каждое новое значение $x_i$ сразу используется для вычисления последующих элементов на той же итерации, что ускоряет сходимость по сравнению с методом Якоби.
- Метод требует, чтобы матрица $A$ имела **диагональное преобладание** для гарантированной сходимости.

## 4. Описание схемы параллельного алгоритма

Для ускорения решения системы методом Зейделя используется **параллельная реализация с MPI**, основанная на распределении строк матрицы между процессами.  

**Схема работы алгоритма:**

1. **Инициализация MPI**:  
   - Каждый процесс получает свой ранг `rank` и общее число процессов `size`.

2. **Разделение данных**:  
   - Матрица $A$ и вектор $b$ делятся по строкам между процессами.  
   - Если количество строк $n$ не кратно числу процессов, первые процессы получают на одну строку больше, чтобы сбалансировать нагрузку.  
   - Нулевой процесс имеет доступ к входным данным задачи, и рассылает каждому процессу размерность матрицы коэффициентов, а затем - соответсвующие ему строки матрицы $A$ и коэффициенты вектора $b$.

3. **Локальные вычисления**:  
   - Каждый процесс обновляет элементы решения $x$ для своей части строк по формуле метода Зейделя, используя актуальные значения из предыдущих итераций.

4. **Обмен результатами**:  
   - После каждой итерации локальные части вектора $x$ собираются у всех процессов с помощью `MPI_Allgatherv`.  
   - Это обеспечивает доступ каждого процесса к полному вектору текущего решения для следующей итерации.

5. **Проверка сходимости**:  
   - Каждый процесс вычисляет локальную максимальную погрешность`local_max_error` (модуль разницы компоненты текущего вектора решения и компоненты старого решения).  
   - Глобальная погрешность `global_max_error` определяется как максимальная из локальных с помощью MPI-функции `MPI_Allreduce`, использующей в качестве параметра `MPI_MAX`.  
   - Итерации прекращаются, если глобальная погрешность решения становится меньше заранее заданного положительного `eps`.

6. **Завершение вычислений**:  
   - Освобождаются локальные буферы и выполняется `MPI_Barrier` для синхронизации процессов.  
   - Вектор `x` содержит решение системы и доступен на всех процессах.

**Особенности параллельной реализации:**

- Декомпозиция по строкам обеспечивает равномерное распределение нагрузки между процессами.  
- Использование `MPI_Allgatherv` и `MPI_Allreduce` обеспечивает корректность вычислений и проверку сходимости на каждой итерации.  

## 5. Проведение экспериментов

### 5.1 Условия экспериментов

- Размер системы линейных уравнений: $n = 6000$  
- Среда выполнения: Windows 10, процессор 4 ядра, MPI (OpenMPI 4.1)  
- Число процессов MPI: 1, 2, 4  
- Последовательная версия (SEQ) запускается на одном процессе  
- Измерение времени: встроенные средства тестового фреймворка GoogleTest с фиксированной точностью  

### 5.2 Результаты времени выполнения и ускорения

| Режим выполнения | Число процессов | Время (сек) | Ускорение | Эффективность, % |
|:-----------------|---------------:|------------:|----------:|----------------:|
| SEQ              | 1              | 0.8315130400        | 1.00      | –               |
| MPI              | 2              | 0.7673245600       | 1.08      | 0.54           |
| MPI              | 4              | 0.6182047200        | 1.35      | 0.33            |
| MPI              | 8              | 1.1137610600        | 0.75      | 0.09           |


**Выводы по производительности:**

- Наиболее эффективно себя показало использование 4 процессов, при котором получено ускорение на 30 %, это не очень много и объясняется накладными расходами по времени на организацию параллельных вычислений.
- Эффективность использования процессов уменьшается при увеличении числа процессов из-за накладных расходов на коммуникацию.
 
## Подтверждение корректности

Функциональные тесты проверяли алгоритмы на следующих системах:

1. Пустая система  
2. Система из одного уравнения  
3. 2×2, 3×3, 4×4 системы с отрицательными и дробными элементами  

**Результаты:**    
- Решения, которые вернули алгоритмы, сравнивались с вектором, являющимся точным решением соответсвующей системы линейных уравнений.  
- Последовательная и параллельная версии дают максимальную погрешность с правильным решением не более 0.0001 для всех тестов.  

Таким образом, обе реализации метода Зейделя работают корректно.

---
## 6. Выводы и заключение

1. Реализованы **последовательная (SEQ)** и **параллельная (MPI)** версии метода Зейделя для решения систем линейных уравнений.  
2. Проверена корректность обеих реализаций с помощью функциональных тестов на системах разного размера и содержания; результаты с достаточной точностью совпадают с эталонными решениями.  
3. Проведены эксперименты на производительность на вычислительной машине с 4 ядрами, использовалась система линейных уравнений размера $n = 6000$:  
   - Параллельная версия MPI показала ускорение по сравнению с последовательной реализацией.  
   - Эффективность использования процессов уменьшается с ростом числа процессов, начиная от 4 процессов, из-за накладных расходов на обмен данными.  
4. Метод Зейделя эффективно решает большие системы при правильном выборе числа процессов и обеспечивает точное решение с высокой сходимостью при диагональном преобладании матрицы.  

**Заключение:**  
В ходе лабораторной работы был изучен итерационный метод Зейделя, реализован в последовательной и параллельной версиях, также была проверена корректность и измерена производительность реализаций алгоритма. MPI-реализация показала преимущество при решении больших систем, подтверждая эффективность распределения вычислений между процессами.
---
## Список литературы
1. Документация по OpenMPI — https://www.open-mpi.org/doc/
2. cppreference.com - https://en.cppreference.com/
3. Лекции по параллельному программированию ННГУ
---






